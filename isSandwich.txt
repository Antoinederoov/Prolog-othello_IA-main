% Student exercise profile
:- set_prolog_flag(occurs_check, error).        % disallow cyclic terms
:- set_prolog_stack(global, limit(8 000 000)).  % limit term space (8Mb)
:- set_prolog_stack(local,  limit(2 000 000)).  % limit environment space

% Your program goes here

% %Switch player
switchPlayer('b','w').
switchPlayer('w','b').

%Check if its a sandwich or not
check_sandwich(_, []) :- !, fail.
check_sandwich(_, [H|_]) :- var(H), !, fail.
check_sandwich(Player, [H|_]) :- H == Player.
check_sandwich(Player, [H|T]) :- H \== Player, check_sandwich(Player,T).

%Get the disk at a precise index
getDisk(Board, Index, Disk) :- nth0(Index, Board, Disk).

%List all the disk in a precise direction from the index to the last cell of the direction
listDiskInDirection(_,Index,Direction,List,FinalList) :- \+ nextCell(Index,Direction,_), !, FinalList = List.
listDiskInDirection(Board,Index,Direction,List,FinalList) :- nextCell(Index,Direction,NextCellIndex), 
    getDisk(Board, NextCellIndex, Disk), 
    append(List,[Disk],NewList), 
    listDiskInDirection(Board,NextCellIndex,Direction,NewList,FinalList).

%Get the next cell depends on the direction, false if there is no more
nextCell(CellIndex, top, NextCellIndex) :- NextCellIndex is CellIndex-8, NextCellIndex > -1.
nextCell(CellIndex, down, NextCellIndex) :- NextCellIndex is CellIndex+8, NextCellIndex < 64.
nextCell(CellIndex, left, NextCellIndex) :- Mod is CellIndex mod 8, Mod =\= 0, NextCellIndex is CellIndex-1.
nextCell(CellIndex, right, NextCellIndex) :- Mod is CellIndex mod 8, Mod =\= 7, NextCellIndex is CellIndex+1.
nextCell(CellIndex, diagNW, NextCellIndex) :- Mod is CellIndex mod 8, Mod =\= 0, X is CellIndex-9, X > -1, NextCellIndex is CellIndex-9.
nextCell(CellIndex, diagNE, NextCellIndex) :- Mod is CellIndex mod 8, Mod =\= 7, X is CellIndex-7, X > -1, NextCellIndex is CellIndex-7.
nextCell(CellIndex, diagSE, NextCellIndex) :- Mod is CellIndex mod 8, Mod =\= 7, X is CellIndex+9, X < 64, NextCellIndex is CellIndex+9.
nextCell(CellIndex, diagSW, NextCellIndex) :- Mod is CellIndex mod 8, Mod =\= 0, X is CellIndex+7, X < 64, NextCellIndex is CellIndex+7.

%Check sandwich which return an empty list if false
isSandwich(Board,Player,Index,Direction) :- switchPlayer(Player,Opponent), %check sandwich par rapport à la couleur opposée
listDiskInDirection(Board,Index,Direction,[],FinalList),
nth0(0, FinalList, Temp), %True when Temp is the first element of List.
nonvar(Temp), Temp == Opponent,
check_sandwich(Player, FinalList).
/** <examples> Your example queries go here, e.g.
?- member(X, [cat, mouse]).
*/


?- isSandwich([
'x','w','w','b','w','b','x','x',
'b','b','b','b','w','b','w','x',
'b','b','w','b','w','b','w','x',
'b','b','w','b','w','b','w','b',
'b','b','b','b','w','b','w','b', 
'b','b','x','b','w','b','w','b',
'x','b','w','b','w','b','w','x',
'x','x','w','b','w','b','x','x'],'b',10, down) 



countCoinSandwich(IndexHypothese, down, [H|T], Player, FinalCoins) :- switchPlayer(Player, Opponent),
H == Opponent,
FinalCoins is FinalCoins+1,
countCoinSandwich(NextCellIndex, down, T, Player, FinalCoins).
countCoinSandwich(CellIndex, down, [_|Opponent], Player, FinalCoins)

countCoinSandwich(IndexHypothese, down, [H|T], Player, FinalCoins) :- switchPlayer(Player, Opponent),
H /= Opponent, H /= Player,
countCoin
countCoinSandwich(NextCellIndex, down, T, Player, FinalCoins).
countCoinSandwich(CellIndex, down, [_|Opponent], Player, FinalCoins)